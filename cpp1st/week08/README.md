# Exception and error handling

## ```std::exception```
Provides consistent interface to handle errors through the throw expression.
All exceptions generated by the standard library inherit from ```std::exception```.

* ```std::logic_error```: Defines a type of object to be thrown as exception. It reports errors that are a consequence of faulty logic within the program such as violating logical preconditions or class invariants and may be preventable.
  * ```std::invalid_argument```: Defines a type of object to be thrown as exception. It reports errors that arise because an argument value has not been accepted. This exception is thrown by ```std::bitset::bitset```, and the ```std::stoi``` and ```std::stof``` families of functions.
  * ```std::domain_error```: Defines a type of object to be thrown as exception. It may be used by the implementation to report domain errors, that is, situations where the inputs are outside of the domain on which an operation is defined. The standard library components do not throw this exception (mathematical functions report domain errors as specified in ```math_errhandling```).
  * ```std::length_error```: Defines a type of object to be thrown as exception. It reports errors that result from attempts to exceed implementation defined length limits for some object. This exception is thrown by member functions of ```std::basic_string``` and ```std::vector::reserve```.
  * ```std::out_of_range```: Defines a type of object to be thrown as exception. It reports errors that are consequence of attempt to access elements out of defined range. It may be thrown by the member functions of ```std::bitset``` and ```std::basic_string```, by ```std::stoi``` and ```std::stod``` families of functions, and by the bounds-checked member access functions (e.g. ```std::vector::at``` and ```std::map::at```).
  * ```std::future_error```: The class std::future_error defines an exception object that is thrown on failure by the functions in the thread library that deal with asynchronous execution and shared states (```std::future```, ```std::promise```, etc). Similar to ```std::system_error```, this exception carries an error code compatible with ```std::error_code```.


* ```std::runtime_error```: Defines a type of object to be thrown as exception. It reports errors that are due to events beyond the scope of the program and can not be easily predicted.
  * ```std::range_error```: Defines a type of object to be thrown as exception. It can be used to report range errors (that is, situations where a result of a computation cannot be represented by the destination type). The only standard library components that throw this exception are ```std::wstring_convert::from_bytes``` and ```std::wstring_convert::to_bytes```.
  * ```std::overflow_error```: Defines a type of object to be thrown as exception. It can be used to report arithmetic overflow errors (that is, situations where a result of a computation is too large for the destination type). The only standard library components that throw this exception are ```std::bitset::to_ulong``` and ```std::bitset::to_ullong```.
  * ```std::underflow_error```: Defines a type of object to be thrown as exception. It may be used to report arithmetic underflow errors (that is, situations where the result of a computation is a subnormal floating-point value).
  * ```std::regex_error```: Defines the type of exception object thrown to report errors in the regular expressions library.
  * ```std::system_error```: std::system_error is the type of the exception thrown by various library functions (typically the functions that interface with the OS facilities, e.g. the constructor of ```std::thread```) when the exception has an associated ```std::error_code```, which may be reported.
  * ```std::ios_base::failure```: The class ```std::ios_base::failure``` defines an exception object that is thrown on failure by the functions in the Input/Output library.

* ```std::bad_typeid```: An exception of this type is thrown when a typeid operator is applied to a dereferenced null pointer value of a polymorphic type.
* ```std::bad_cast```: An exception of this type is thrown when a dynamic_cast to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from ```std::use_facet``` if the requested facet does not exist in the locale.
* ```std::bad_weak_ptr```: ```std::bad_weak_ptr``` is the type of the object thrown as exceptions by the constructors of ```std::shared_ptr``` that take ```std::weak_ptr``` as the argument, when the ```std::weak_ptr``` refers to an already deleted object.
* ```std::bad_function_call```: ```std::bad_function_call``` is the type of the exception thrown by ```std::function::operator()``` if the function wrapper has no target.
* ```std::bad_alloc```: ```std::bad_alloc``` is the type of the object thrown as exceptions by the allocation functions to report failure to allocate storage.
* ```std::bad_array_new_length```: ```std::bad_array_new_length``` is the type of the object thrown as exceptions by the new-expressions to report invalid array lengths if

  1) array length is negative
  2) total size of the new array would exceed implementation-defined maximum value
  3) the number of initializer-clauses exceeds the number of elements to initialize 
  
  Only the first array dimension may generate this exception; dimensions other than the first are constant expressions and are checked at compile time.
* ```std::bad_exception```: ```std::bad_exception``` is the type of the exception thrown by the C++ runtime in the following situations:
  * If ```std::exception_ptr``` stores a copy of the caught exception and if the copy constructor of the exception object caught by ```std::current_exception``` throws an exception, the captured exception is an instance of ```std::bad_exception```.

## ```throw``` expression
Signals an erroneous condition and executes an error handler.

### Explanation
* First, copy-initializes the exception object from expression 
  
  * This may call the move constructor for rvalue expression (since C++11)
  * This may also call the move constructor for lvalue expressions if they name local variables or function or catch-clause parameters whose scope does not extend past the innermost enclosing try-block (if any), by same two-step overload resolution as in return statement (since C++17)
  * The copy/move (since C++11) may be subject to copy elision
  * Even if copy initialization selects the move constructor, copy initialization from lvalue must be well-formed, and the destructor must be accessible (since C++14)
  
  then transfers control to the exception handler with the matching type for which the compound statement or member initializer list that follows the keyword try was most recently entered and not exited by this thread of execution.
* Rethrows the currently handled exception. Abandons the execution of the current catch block and passes control to the next matching exception handler (but not to another catch clause after the same try block: its compound-statement is considered to have been 'exited'), reusing the existing exception object: no new objects are made. This form is only allowed when an exception is presently being handled (it calls std::terminate if used otherwise). The catch clause associated with a function-try-block must exit via rethrowing if used on a constructor.

* See ```std::terminate``` and ```std::unexpected``` (until C++17) for the handling of errors that arise during exception handling.

### The exception object
The exception object is a temporary object in unspecified storage that is constructed by the throw expression.

The type of the exception object is the static type of expression with top-level cv-qualifiers removed. Array and function types are adjusted to pointer and pointer to function types, respectively. If the type of the exception object would be an incomplete type, an abstract class type, or pointer to incomplete type other than pointer to (cv-qualified) void, the throw-expression is a compile-time error. If the type of expression is a class type, its copy/move (since C++11) constructor and destructor must be accessible even if copy elision takes place.

Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.

The exception object persists until the last catch clause exits other than by rethrowing (if not by rethrowing, it is destroyed immediately after the destruction of the catch clause's parameter), or until the last ```std::exception_ptr``` that references this object is destroyed (in which case the exception object is destroyed just before the destructor of ```std::exception_ptr``` returns.

### Stack unwinding
Once the exception object is constructed, the control flow works backwards (up the call stack) until it reaches the start of a try block, at which point the parameters of all associated catch blocks are compared, in order of appearance, with the type of the exception object to find a match (see try-catch for details on this process). If no match is found, the control flow continues to unwind the stack until the next try block, and so on. If a match is found, the control flow jumps to the matching catch block.

As the control flow moves up the call stack, destructors are invoked for all objects with automatic storage duration that are constructed, but not yet destroyed, since the corresponding try-block was entered, in reverse order of completion of their constructors. If an exception is thrown from a destructor of a local variable or of a temporary used in a return statement, the destructor for the object returned from the function is also invoked. (since C++14)

If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors. Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined. (since C++14)

If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called. (since C++11)

If the exception is thrown from a constructor that is invoked by a new-expression, the matching deallocation function is called, if available.

This process is called stack unwinding.

If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, ```std::terminate``` is called. Such functions include destructors of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (if not elided) to initialize catch-by-value arguments.

If an exception is thrown and not caught, including exceptions that escape the initial function of ```std::thread```, the main function, and the constructor or destructor of any static or thread-local objects, then ```std::terminate``` is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.

### Reference
[[1] Klaus Iglberger. 2020. Back to Basics: Exceptions. Video. CppCon.](https://youtu.be/0ojB8c0xUd8) <br>
[[2] Ben Saks. 2019. Back to Basics: Exception Handling and Exception Safety. Video. CppCon.](https://youtu.be/W6jZKibuJpU) <br>
[[3] C++ reference. 2022. std::exception.](https://en.cppreference.com/w/cpp/error/exception) <br>
[[4] C++ reference. 2022. throw expression.](https://en.cppreference.com/w/cpp/language/throw) <br>